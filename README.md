Домашнее задание к лекции №3.3

1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.


```
chdir("/tmp")
```

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
```
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
```
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.


```
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
```
База данных находится в /usr/share/misc/magic.mgc

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).


Команда просмотра активных процессов с удаленными файлами
```
sudo lsof -a +L1
```

Чтобы очистить место на диске которое занимает удаленный файл
```
truncate -s 0 /proc/1366/fd/4
```
или
```
> /proc/1366/fd/4
```
Где 1366 номер процесса, а 4 номер файлового дескриптора

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?


Зомби не занимают ресурсы, но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом. Чтобы освободить запись, родительскому процессу нужно отправить системный вызов wait() 

5. В iovisor BCC есть утилита opensnoop:
```
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
```
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.


```
root@netology:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
root@netology:~# /usr/sbin/opensnoop-bpfcc
PID    COMM               FD ERR PATH
1      systemd            24   0 /proc/19094/cgroup
631    irqbalance          6   0 /proc/interrupts
631    irqbalance          6   0 /proc/stat
631    irqbalance          6   0 /proc/irq/20/smp_affinity
631    irqbalance          6   0 /proc/irq/0/smp_affinity
631    irqbalance          6   0 /proc/irq/1/smp_affinity
631    irqbalance          6   0 /proc/irq/8/smp_affinity
631    irqbalance          6   0 /proc/irq/12/smp_affinity
631    irqbalance          6   0 /proc/irq/14/smp_affinity
631    irqbalance          6   0 /proc/irq/15/smp_affinity
631    irqbalance          6   0 /proc/interrupts
631    irqbalance          6   0 /proc/stat
```

6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.


```
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
```

7. Чем отличается последовательность команд через ; и через && в bash? Например:
```
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
```
Есть ли смысл использовать в bash &&, если применить set -e?


&&      логический оператор. Вторая команда будет выполняться только в том случае, если первая команда выполнена успешно, т. е. ее статус выхода равен нулю. Этот оператор можно использовать для проверки успешности выполнения первой команды
Синтаксис
```
command1 && command2
```
;      Разделитель последовательных команд. Он используется для выполнения нескольких команд за один раз. Выполнение команды, следующей за этим оператором, всегда будет выполняться после выполнения предыдущей команды, в независимости от состояния выхода предыдущей команды. Команды всегда выполняются последовательно. Статус возврата — это статус выхода последней выполненной команды.

set -e   В случае ошибки, опция прерывает выполнение всех цепочки команды, кроме последней выполненной, по сути это аналог оператора &&, так как выполняют схожую последовательность действий.

8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?


-e     В случае ошибки, опция прерывает выполнение всей цепочки команды, кроме последней выполненной (аналог &&)
-u     Влияет на переменные. Когда установлена ссылка на любую переменную, которую ранее не определили, за исключением $* и $@, является ошибкой и вызывает немедленный выход из программы.
-x     Включает режим оболочки, в котором все выполняемые команды выводятся на терминал
-o pipefail     Этот параметр предотвращает маскирование ошибок в конвейере. В случае сбоя какой-либо команды в конвейере этот код возврата будет использоваться как код возврата для всего конвейера.

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными)


Два наиболее распространенных статуса в столбце STAT: S - процессы в состоянии сна и R - процессы в состоянии выполнения. Спящий процесс — это процесс, который в данный момент не активен. Выполняемый процесс — это процесс, который в данный момент выполняется процессором.

Дополнительные буквы к основной заглавной статуса означают (перевёл смысл как смог):
<    Процесс c высоким - приоритетом
N     с низким приоритетом 
L     имеет страницы, заблокированные в памяти (для реального времени и пользовательского ввода-вывода)
s     является лидером сеанса
l     Процесс является многопоточным
+     находится в группе процессов на переднем плане
